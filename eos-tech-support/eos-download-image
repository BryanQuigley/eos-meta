#!/usr/bin/env python3
# vim: fileencoding=utf-8 sts=4 sw=4 et
import argparse
import codecs
import distutils.version
import gzip
import json
import os
import shlex
import subprocess
import sys
import urllib.parse
import urllib.request

INTERNAL_BASE_URL = "http://images.endlessm-sf.com"
PUBLIC_BASE_URL = "https://d1anzknqnc1kmb.cloudfront.net"
KEYRING_FILENAME = "eos-image-keyring.gpg"
KEYRING_URL = PUBLIC_BASE_URL + "/" + KEYRING_FILENAME
KEYRING_SYSTEM_PATH = "/usr/share/keyrings/eos-image-keyring.gpg"


def log(*args):
    sys.stderr.write('\n')
    print(*args, file=sys.stderr)
    sys.stderr.flush()


def check_call(*args):
    if hasattr(shlex, 'quote'):
        qargs = map(shlex.quote, args)
    else:
        qargs = args
    log('$ ' + ' '.join(qargs))
    subprocess.check_call(args, stdout=sys.stderr)


def url_dirname(url):
    raw_path = urllib.parse.urlparse(url).path
    path = urllib.parse.unquote(raw_path)
    return os.path.dirname(path.lstrip('/'))


def ensure_keyring(destdir=''):
    if os.path.isfile(KEYRING_SYSTEM_PATH):
        return KEYRING_SYSTEM_PATH

    # The absolute path is needed so that gpgv doesn't try to use a
    # keyring from the gnupg homedir
    keyring = os.path.abspath(os.path.join(destdir, KEYRING_FILENAME))
    if not os.path.isfile(keyring):
        log("Fetching Endless keyring")
        check_call("wget", "-O", keyring, KEYRING_URL)

    return keyring


def download_and_verify(base, meta, what='image', destdir='',
                        mirror=False):
    image_url = '{}/{}'.format(base, meta['file'])
    signature_url = '{}/{}'.format(base, meta['signature'])

    image_dir = signature_dir = ''
    if mirror:
        image_dir = url_dirname(image_url)
        signature_dir = url_dirname(signature_url)
    image = os.path.join(destdir, image_dir, os.path.basename(image_url))
    signature = os.path.join(destdir, signature_dir,
                             os.path.basename(signature_url))

    log("Downloading compressed", what, "from", image_url)
    full_image_dir = os.path.dirname(image)
    if full_image_dir:
        os.makedirs(full_image_dir, exist_ok=True)
    check_call("wget", "--continue", "-O", image, image_url)

    if meta.get('extracted_size'):
        with open(image + '.size', 'w') as f:
            f.write(str(meta['extracted_size']))

    log("Downloading compressed", what, "signature from", signature_url)
    full_signature_dir = os.path.dirname(signature)
    if full_signature_dir:
        os.makedirs(full_signature_dir, exist_ok=True)
    check_call("wget", "--continue", "-O", signature, signature_url)

    if meta.get('extracted_signature'):
        url = '{}/{}'.format(base, meta['extracted_signature'])
        ext_sig_dir = ''
        if mirror:
            ext_sig_dir = url_dirname(url)
        ext_signature = os.path.join(destdir, ext_sig_dir,
                                     os.path.basename(url))
        log("Downloading uncompressed", what, "signature from", url)
        full_ext_sig_dir = os.path.dirname(ext_signature)
        if full_ext_sig_dir:
            os.makedirs(full_ext_sig_dir, exist_ok=True)
        check_call("wget", "--continue", "-O", ext_signature, url)

    keyring = ensure_keyring(destdir)

    log("Verifying")
    check_call("gpgv", "--keyring", keyring, signature, image)

    log("Download okay.")
    return image


def main():
    p = argparse.ArgumentParser(
        description='Fetches and verifies an image (installer or regular OS)')
    p.add_argument('-o', '--outdir',
                   help='Output directory (default: current directory)',
                   default='')
    m = p.add_mutually_exclusive_group()
    m.add_argument('-m', '--mirror',
                   action='store_true',
                   help='Mirror all versions and personalities')
    m.add_argument('-v', '--version',
                   help='Image version (default: newest)')
    p.add_argument('-p', '--personality',
                   help='Image personality (default: base, '
                        'ignored when mirroring)',
                   default='base')
    g = p.add_mutually_exclusive_group()
    g.add_argument('-r', '--product',
                   help='Product (eg: eosinstaller; default: eos)',
                   default='eos')
    g.add_argument('-w', '--windows-tool',
                   action='store_true',
                   help='Fetch the Windows USB creator/installer, '
                        'not an Endless OS image')
    p.add_argument('-i', '--internal',
                   action='store_true',
                   help='Fetch images from the Endless internal network')

    args = p.parse_args()

    if args.product == 'fnde' and args.personality == 'base':
        args.personality = 'fnde_aluno'

    base = INTERNAL_BASE_URL if args.internal else PUBLIC_BASE_URL

    # Create the output directory if necessary
    if args.outdir:
        os.makedirs(args.outdir, exist_ok=True)

    if args.windows_tool:
        fetch_windows_tool(args, base)
    else:
        fetch_image(args, base)


def fetch_windows_tool(args, base):
    filename = 'endless-installer.exe'
    url = '{}/endless-installer/{}'.format(base, filename)
    log("Fetching Windows Installer")
    # --timestamping is not compatible with -O, so provide only the
    # output prefix
    check_call("wget", "--timestamping", "--directory-prefix",
               args.outdir, url)
    print(filename)


def fetch_image(args, base):
    manifest_url = '{base}/releases-{product}-3.json.gz'.format(
        base=base, product=args.product)
    req = urllib.request.Request(manifest_url)
    with urllib.request.urlopen(req) as conn:
        with gzip.GzipFile(mode='r', fileobj=conn) as manifest_fp:
            manifest = json.load(codecs.getreader('utf8')(manifest_fp))

    images = list(manifest['images'].values())
    images.sort(key=lambda i: distutils.version.StrictVersion(i['version']))
    if args.mirror:
        selected = images
    elif args.version is not None:
        for img in images:
            if img['version'] == args.version:
                selected = [img]
                break
        else:
            log("Image version", repr(args.version), "not found")
            log("Known versions:", *[i['version'] for i in images])
            sys.exit(1)
    else:
        selected = [images[-1]]

    for img in selected:
        personalities = img['personality_images']
        if not args.mirror and args.personality not in personalities:
            log("Personality", repr(args.personality), "not found")
            log("Known personalities:", *sorted(personalities.keys()))
            sys.exit(1)

        for name, personality in sorted(personalities.items()):
            if args.mirror:
                for meta in sorted(personality):
                    kwargs = {'destdir': args.outdir, 'mirror': True}
                    if meta == 'boot':
                        kwargs['what'] = 'bootloader'
                    print(download_and_verify(base, personality[meta],
                                              **kwargs))
            elif name == args.personality:
                meta = personality['full']
                if 'boot' in personality and personality['boot']['file']:
                    download_and_verify(base, personality['boot'],
                                        what='bootloader', destdir=args.outdir)

                print(download_and_verify(base, meta, destdir=args.outdir))

    # Write out the manifest when mirroring after all images downloaded
    if args.mirror:
        out_manifest = os.path.join(args.outdir,
                                    'releases-{}-3.json'.format(args.product))
        out_manifest_gz = out_manifest + '.gz'
        with open(out_manifest, 'w') as f:
            json.dump(manifest, f, sort_keys=True)
        with gzip.open(out_manifest_gz, 'wt') as f:
            json.dump(manifest, f, sort_keys=True, indent=4)


if __name__ == '__main__':
    main()
