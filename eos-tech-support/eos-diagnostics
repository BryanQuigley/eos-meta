#!/usr/bin/env gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;

function collectGraphicsRenderer() {
    let iface =
        '<node>' +
        '<interface name="org.gnome.SessionManager">' +
        '<property name="Renderer" type="s" access="read"/>' +
        '</interface>' +
        '</node>';

    let sessionProxyProto = Gio.DBusProxy.makeProxyWrapper(iface);
    let sessionProxy = new sessionProxyProto(Gio.DBus.session,
                                             'org.gnome.SessionManager',
                                             '/org/gnome/SessionManager');

    let output = 'Renderer: ';
    if (sessionProxy)
        output += sessionProxy.Renderer;
    else
        output += 'unknown';
    output += '\n';

    return output;
}

function collectBoardInfo() {
    let dmi_info = [ 'sys_vendor', 'product_name', 'product_serial',
                     'product_uuid', 'product_version', 'board_asset_tag',
                     'board_name', 'board_serial', 'board_vendor',
                     'board_version', 'bios_date', 'bios_vendor',
                     'bios_version', 'chassis_asset_tag', 'chassis_serial',
                     'chassis_type', 'chassis_vendor', 'chassis_version' ];
    let output = '';
    dmi_info.forEach(function(name) {
        let file = '/sys/devices/virtual/dmi/id/' + name;

        try {
            let [res, contents] = GLib.file_get_contents(file);
            output += name + ': ' + contents;
        } catch (e) {
        }
    });

    try {
        let [res, contents] = GLib.file_get_contents('/proc/device-tree/compatible');
        output += 'compatible: ' + contents;
    } catch (e) { }

    return output;
}

function collectPrintersInfo() {
    let output = '';
    let ppds_dir_path = '/etc/cups/ppd';

    output += 'CUPS status:\n------------\n';
    try {
        let argv = ['/usr/bin/lpstat', '-t'];
        let envp = ['LANG=C'];
        let [res, stdout, stderr, exitStatus] = GLib.spawn_sync(null, argv, envp,
                                                                GLib.SpawnFlags.DEFAULT,
                                                                null, null);
        output += stdout;
    } catch (e) {
        output += 'error ocurred querying CUPS status: ' + e + '\n';
    }

    let ppds_dir = Gio.file_new_for_path(ppds_dir_path);
    if (!ppds_dir.query_exists(null)) {
        output += ppds_dir_path + ' not found';
        return output;
    }

    try {
        let installed_ppds = ppds_dir.enumerate_children('standard::name',
                                                         Gio.FileQueryInfoFlags.NONE,
                                                         null)
        let ppd_info = null;
        while ((ppd_info = installed_ppds.next_file(null))) {
            let ppd_path = GLib.build_filenamev([ppds_dir_path, ppd_info.get_name()]);
            output += '\nContents for ' + ppd_path + ':\n-------------';
            for (let i = 0; i < ppd_path.length; i++)
                output += '-';
            output += '-\n';

            try {
                let [res, contents] = GLib.file_get_contents(ppd_path);
                output += contents;
            } catch (e) {
                output += 'not available\n';
            }
        }
    } catch (e) {
        output += 'Unable to find installed PPD files: ' + e + '\n';
    }

    return output;
}

function collectTemperatureInfo() {
    try {
        let [res, tempInput] = GLib.file_get_contents('/sys/class/thermal/thermal_zone0/temp');
        let temperature = parseInt(tempInput);
        let temperatureStr = (temperature / 1000).toString() + 'Â°C';
        return ((temperature > 0) ? ('+') : ('-')) + temperatureStr + '\n';
    } catch (e) {
        return 'No temperature information available\n';
    }
}

function collectChromiumPluginsInfo() {
    let oldVersion = null;
    try {
        let [res, version] = GLib.file_get_contents('/var/lib/chromium-plugins-extra/eos-chrome-plugin-updater/VERSION.txt');
        oldVersion = version + ' (via old updater)\n';
    } catch(e) {
        oldVersion = null;
    }

    let flashOutput = 'Flash Version: ';
    let flashPath = Gio.file_new_for_path('/var/lib/chromium-plugins-extra/eos-chrome-plugin-updater/libpepflashplayer.so');
    if (flashPath.query_exists(null)) {
        try {
            let [res, version] = GLib.file_get_contents('/var/lib/chromium-plugins-extra/eos-chrome-plugin-updater/Flash_VERSION.txt');
            flashOutput += version + '\n';
        } catch(e) {
            flashOutput += (oldVersion != null) ? oldVersion : 'not available\n';
        }
    } else {
        flashOutput += 'not installed\n';
    }

    let widevineOutput = 'Widevine Version: ';
    let widevinePath = Gio.file_new_for_path('/var/lib/chromium-plugins-extra/eos-chrome-plugin-updater/libwidevinecdm.so');
    if (widevinePath.query_exists(null)) {
        try {
            let [res, version] = GLib.file_get_contents('/var/lib/chromium-plugins-extra/eos-chrome-plugin-updater/Widevine_VERSION.txt');
            widevineOutput += version + '\n';
        } catch(e) {
            widevineOutput += (oldVersion != null) ? oldVersion : 'not available\n';
        }
    } else {
        widevineOutput += 'not installed\n';
    }

    return flashOutput + widevineOutput;
}

function collectEosDevInfo() {
    let output = '';
    let dpkgDir = Gio.File.new_for_path('/var/lib/dpkg');
    if (dpkgDir.query_exists(null)) {
        output += '*************************************************************\n';
        output += '*                        WARNING                            *\n';
        output += '* eos-dev-fix or eos-convert-system was run on the system!! *\n';
        output += '*************************************************************\n';
        output += '\n';
    }

    return output;
}

function trySpawn(command) {
    try {
        let [res, stdout, stderr, exitStatus] = GLib.spawn_command_line_sync(command);
        return stdout.toString();
    } catch (e) {
        return '';
    }
}

function tryReadFile(filename, fallbackMessage) {
    try {
        let [res, contents] = GLib.file_get_contents(filename);
        return contents.toString();
    } catch (e) {
        return (fallbackMessage) ? fallbackMessage : '';
    }
}

let diagnostics = [
    {
        title: 'EndlessOS version',
        content: function() { return tryReadFile('/etc/os-release'); },
    },
    {
        title: 'Kernel version',
        content: function() { return trySpawn('uname -a'); },
    },
    {
        title: 'EndlessOS image',
        content: function() {
            return trySpawn('attr -q -g eos-image-version /sysroot') +
                   trySpawn('attr -q -g eos-image-version /');
        },
    },
    {
        title: 'EndlessOS personality',
        content: function() {
            return tryReadFile('/etc/EndlessOS/personality.conf',
                               'No personality file\n');
        },
    },
    {
        title: 'Uptime',
        content: function() { return trySpawn('uptime'); },
    },
    {
        title: 'OSTree status',
        content: function() { return trySpawn('ostree admin status'); },
    },
    {
        title: 'Product identification',
        content: function() { return collectBoardInfo(); },
    },
    {
        title: 'Memory',
        content: function() { return trySpawn('free -mh'); },
    },
    {
        title: 'Disks',
        content: function() { return trySpawn('udisksctl dump'); },
    },
    {
        title: 'Mounts',
        content: function() {
            return trySpawn('mount') + '\n' + trySpawn('df -h');
        },
    },
    {
        title: 'Network interfaces',
        content: function() { return trySpawn('ifconfig -a'); },
    },
    {
        title: 'Graphics',
        content: function() { return collectGraphicsRenderer(); },
    },
    {
        title: 'Display',
        content: function() { return trySpawn('xrandr -q --verbose'); },
    },
    {
        title: 'Pulseaudio',
        content: function() { return trySpawn('pactl list'); },
    },
    {
        title: 'PCI devices',
        content: function() { return trySpawn('lspci -knn'); },
    },
    {
        title: 'USB devices',
        content: function() { return trySpawn('lsusb'); },
    },
    {
        title: 'Printers',
        content: function() { return collectPrintersInfo(); },
    },
    {
        title: 'Temperature',
        content: function() { return collectTemperatureInfo(); },
    },
    {
        title: 'Chromium plugins',
        content: function() { return collectChromiumPluginsInfo(); }
    },
    {
        title: 'Codecs',
        content: function() {
            return trySpawn('find /var/lib/codecs') + '\n' +
                   trySpawn('gst-inspect-1.0 libav') +
                   trySpawn('gst-inspect-1.0 -b');
        },
    },
    {
        title: 'Flatpak remotes',
        content: function() {
            return trySpawn('flatpak remote-list --show-details');
        },
    },
    {
        title: 'Processes',
        content: function() { return trySpawn('ps aux'); },
    },
    {
        title: 'Boot timing',
        content: function() { return trySpawn('systemd-analyze'); },
    },
    {
        title: 'Journal',
        content: function() { return trySpawn('journalctl --no-pager'); },
    },
];

function dumpDiagnostics(filename) {
    let fullDump = '';

    fullDump += collectEosDevInfo();

    diagnostics.forEach(function(diag) {
        fullDump += '='.repeat(diag.title.length + 4) + '\n';
        fullDump += '= ' + diag.title + ' =\n';
        fullDump += '='.repeat(diag.title.length + 4) + '\n';
        let content = diag.content().trim();
        fullDump += content + '\n\n';
    });

    if (filename == 'stdout') {
        print(fullDump);
    } else {
        try {
            GLib.file_set_contents(filename, fullDump);
            log('Saved to ' + filename);
        } catch (e) {
            log('Can\'t save diagnostic file to ' + filename + ': ' + e.message);
        }
    }
}

let fileArg = ARGV[0];
let filename;

if (fileArg) {
    filename = fileArg;
} else {
    let date = GLib.DateTime.new_now_local();
    let basename = 'eos-diagnostic-' + date.format('%y%m%d_%H%M%S_UTC%z') + '.txt';
    filename = GLib.build_filenamev([GLib.get_home_dir(), basename]);
}

dumpDiagnostics(filename);
